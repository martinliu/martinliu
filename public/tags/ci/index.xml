<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ci on DevOps &amp; SRE Blog</title>
    <link>https://martinliu.cn/tags/ci/</link>
    <description>Recent content in ci on DevOps &amp; SRE Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 06 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://martinliu.cn/tags/ci/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在 Github 上搭建基于 Hugo 的免费个人博客</title>
      <link>https://martinliu.cn/blog/change-back-on-github-page-again/</link>
      <pubDate>Sat, 06 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://martinliu.cn/blog/change-back-on-github-page-again/</guid>
      <description>&lt;p&gt;最近更新了新的博客样式，再次搬迁回到了 GitHub 平台，并使用了 Github Action 的自动化 CI/CD 发布功能。这个是一个任何人都可以拥有的方案，现在用最简洁的语言分享给大家。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Skaffold 让 K8s 开发者更加酸爽</title>
      <link>https://martinliu.cn/blog/skaffold-make-local-k8s-dev-easy/</link>
      <pubDate>Wed, 15 Jul 2020 00:09:53 +0800</pubDate>
      
      <guid>https://martinliu.cn/blog/skaffold-make-local-k8s-dev-easy/</guid>
      <description>今天介绍一个本地 Kubernetes 开发的利器 Skaffold。 这是我偶然间发现的一个工具，询问了一下周围的人，居然还没有人用过。测试之后，确实有一种不吐不快的感觉。
简介 Skaffold Google 开发的一个开源项目。是一个非常轻量的命令行工具，就是一个可执行文件。它的主页上是这样的介绍它的。
 轻量：Skaffold只是一个客户端工具。由于集群上不需要任何的相关组件，您的集群没有任何开销或维护负担。 运行在任何地方：Skaffold是与世界分享你的项目的最简单的方法：&amp;ldquo;git clone&amp;rdquo;，然后 &amp;ldquo;skaffold run&amp;rdquo;。此外，你还可以使用配置文件、本地用户配置、环境变量和标志来轻松地集成不同环境的差异。 功能丰富：Skaffold拥有许多Kubernetes原生开发的基本功能，包括基于策略的打镜像标签、资源端口转发和日志、文件同步等。 优化你的开发：Skaffold使内部循环紧密，高度优化，让您在开发的同时得到即时反馈。  客户评价 &amp;ldquo;我们的客户很喜欢[Kubernetes]，但一直给我们反馈说在Kubernetes上开发很麻烦。Skaffold一针见血地解决了这个问题。以前需要几分钟才能部署的docker镜像或配置的更改，现在只需要几秒钟。Skaffold的插件架构使我们能够部署到Helm或Kustomize，并使用各种docker构建插件，如Kaniko。Skaffold用一个精简的工具取代了我们定制的实用程序和脚本集合，并且易于使用。&amp;rdquo; Warren Strange，ForgeRock的工程总监。
&amp;ldquo;当我们评估我们可以使用Kubernetes的工作流程时，Skaffold脱颖而出，成为我们在开发和部署中都想要的工具。它为我们提供了一个跨应用程序的通用入口点，我们也可以为CI/CD重用。现在，我们所有的Kubernetes应用的CI/CD管道在构建和部署时都使用Skaffold。&amp;rdquo; Taylor Barrella，Quora的软件工程师
&amp;ldquo;Skaffold是一个了不起的工具，它为我们简化了开发和交付。Skaffold通过覆盖两个维度，击中了我们的甜蜜点。第一，从本地开发、集成测试到交付的整个开发周期。第二，Skaffold让我们能够在Linux、OSX和Windows上独立开发，不需要特定的平台逻辑。&amp;rdquo; Martin Höfling，TNG技术咨询有限公司首席顾问
推荐首次测试流程 前置条件，你的开发用工作电脑上已经安装了它需要调用的 kubectl 和 docker 命令，kubectl 需要有至少一个可用的配置，这个配置可以指向任一一个你有权限部署的 Kubernetes 集群。
我在 macOS 上，直接运行 ‌brew install skaffold 即可，其它系统参考：https://skaffold.dev/docs/install/
克隆 Skaffold 的代码库到本地，获取必要的测试应用代码。
‌git clone https://github.com/GoogleContainerTools/skaffold
进入代码库中的‘hello world’示例应用。
执行：‌cd skaffold/examples/getting-started
执行 ‌skaffold dev ，你会看到 Skaffold 进入了这个项目的构建和运行的状态，执行结果是持续的输出 ”[getting-started] Hello world!“
现在 Skaffold 就进入了 /getting-started 的监视状态。观察任何代码文件的修改存盘动作，每次代码的变更会触发 Skaffold 流水线的执行，skaffold.yaml 文件中描述了本地流水线中的相关动作：</description>
    </item>
    
    <item>
      <title>基础架构的持续集成和应用部署</title>
      <link>https://martinliu.cn/blog/devops-infrastructure-ci-app-deployment/</link>
      <pubDate>Sat, 17 Mar 2018 10:50:57 +0800</pubDate>
      
      <guid>https://martinliu.cn/blog/devops-infrastructure-ci-app-deployment/</guid>
      <description>持续集成通常是针对应用而言的，可是基础架构的持续集成应该怎么做？基础架构的持续集成应该属于持续交付/部署的基础。贯串本文的一个问题，或者在阅读本文时，您应该不断地问自己这个问题：我们的应用部署流程是怎样的？
在回答这个问题之前，我们先来回顾一下，目前几乎所有人正在使用的手工环境和资源交付流程。在源码被编译打包了以后，安装包文件被上传保存到了内部的某个文件服务器上。Ops团队的某个组/人被分配到工单，根据工单描述的需求，它在测试或者生产环境中开始工作：
 用图形界面进行虚拟机模板的手工克隆工作，或者由于没有相应的权限或者自助服务，不得不给虚拟化管理员发任务单，然后等待回复。 获取用户名和密码手工登录服务器，有些企业还要是等待领导的审批，才能得到密码信封和所需要的访问密码。 根据工单（变更单）里的描述和自己的经验对虚拟机的操作系统进行配置，在这个过程中，Ops往往可能还需和需求方进行不止一次的沟通，确认相关参数。 手工的下载应用安装包，然后分别手工上传到目标的服务器，凭经验和工单信息部署应用，然后测试部署结果，可能是看下页面有没有正常显示，或者服务起没起. 手工测试和确认这些虚拟机的服务和状态，凭经验觉得OK了以后，回复工单，关闭工单。  以上的工作场景，可能是Ops人员很常规的一天，或者是几天内的工作，当然在这个过程中，他们还需要参与一些救火行动；他们在这个过程中也可能会有疑问，也可能会对此工作结果不确定；但是，日常的工作经验告诉他，差不多了，关闭任务单要紧，还有好多项目催活呢！就这样，配置并不精确的虚拟机环境就交给了下游的需求方。
以上工作过程的问题如下：
 工作周期长，速度慢。实际上工作周期拖延的越久，工作结果的质量就越差，而并不是我们想想中的慢工出细活。 所有步骤都是纯手工操作，不仅费事费力，而且出错几率高，也几乎不可能无痛的回退。可能有人会说了，我们不需要那么快，我们也不是互联网公司；可是从精益思想的角度看，以上这些工作都属于对业务价值的交付贡献为零的工作；你可能是由于公司给你发着工资，才错误的感觉到，这项工作活动应该有它的价值。 上游传递来的信息可能不全面，不准确，因此Ops很有可能造成错误配置，因此会返工。 传递给下游的虚拟机很可能会在后续的部署过程中，由于应用需求的变化，而需要下游的人员对其重新配置，产生重复的劳动。   手工部署的时间和代价 = 应的数量 X 应用版本数量 X 环境数量
 对以上工作系统进行优化的原则：如果某一项活动的重复频率越高，那么对它进行优化，所产生的回报也会越明显；这里还要参考限制理论，优化的顺序要正确。
我们从这个角度出发，就可以来设定基础架构持续集成和应用部署流程的改进目标了：
 减少总体人工工作时间和代价 提高交付的速度、可靠性和频率 能进行应用部署，能进行数据库Schema的更新 能够实现部署流程的自服务，让任何需要部署应用的人能一键式部署任何版本  到了这里我们就必须将上述手工劳动，变为自动化的过程。因此，基础架构即代码IaC （Infrastructure as code）和相关的配置管理工具就会用到。
上图是一个典型的持续交付流水线模型，在此我们对它的关注点如下：
 代码的变更被Jenkins自动化的构建（CI是基础），打包后的安装包被存储在Artifactory里，Artifactory里面还可以存储应用包的其它相关元数据，如测试结果，能否可以用于下一步部署的标签等等。 Jenkins自动化的搭建所需要的环境，调用虚拟化或者公有云资源池的API，制备虚拟机资源，然后调用Chef完成对虚拟机的配置，完成应用包部署所需要的所有层次的配置。 环境配置完成后，应用正常运行了，在相关的测试工具对部署后的环境做验收测试，Chef具有支持测试驱动的相关工具。  基础架构的持续集成 为了实现完整的基础架构持续集成流程，以上持续交付流水线必须具备的能力和概念包括：分层的系统管理、基础架构即代码IaC、配置管理、Chef工具等。下面详细对它们进行描述。
分层的系统管理 系统管理的层次涉及到OS相关的三个层次。下面自下而上地简单描述一下。
 制备管理：涉及到虚拟化层，这一层是资源表达层，目前所有主流的虚拟化都支持标准的Rest API，包括VMWare、EC2和Nuanix等。大多数主流配置管理工具都具备用于虚拟机生命周期管理（从生成、到开机、到删除等）的API功能，能按需的获得任何数量、规模、网络和操作系统类型的部署环境。 配置管理：在任何类型的操作系统里自动化的安装和配置软件包，将所有配置参数配置好以后，持续保持这些配置点的状态。对于简单应用，来说按配置参数启动服务即任务完成。 应用编排管理：对于复杂的分布式系统，由于各个自服务之间存在着依赖关系，所有自服务之前需要互通一些配置参数才能实现，应用程序整体的正常运行，配置应用服务器的odbc数据库连接，配置web前端的ldap认证服务器等等。目前微服务所涉及的服务发现和路由，是应用编排必备的配套设施。  不同的DevOps配置管理工具也都力求能覆盖以上三个层次，但是他们所追求的方向，或者想解决的主要问题并不相同。因此各个工具之间功能上有重叠。
因此在运用这些工具的时候，不仅要追求其卓越的功能，还要能意识到，并有意的在不同层面上做取舍。
基础架构即代码 IaC这个概念最早是被Chef这类工具提出并实现，它的基本想法就是让Ops人员象开发人员一样的，工作在基础架构的代码上，而不是面对着数十个图形和文字终端界面。使用类似于开发应用程序的方式，开发和管理基础架构环境，因此基础架构能通过API访问和操控是基础，目前所有主流的虚拟化/云计算平台都具备很好的API接口；可惜的是在传统的企业环境中，这些资源池的API功能几乎没有被用到。
像开发应用代码一样的管理IT基础架构，基础架构的开发和管理也需要遵循与应用开发类似的原则，这些原则包括：
 一切从源代码开始:并对其进行严格的版本管理，要对基础架构变更，就需要对相应的代码进行变更和测试，最后发布这些代码。从而力求做到服务器的无人登录运维。 模块化设计:不同应用底层所使用的基础架构有着大量的相似之处，模块化的设计不仅意味着标准化，也意味着更少的重复代码。我所用过的Terraform、Chef和Puppet这三种工具，都具有高度的模块化特性。 抽象能力：能够使用不同的模块和参数对任何特征的应用进行建模，用IaC代码进行表达，基础架构的代码开发也就是借助这种抽象能力，将所有管理对象（配置管理项）具体化地描述为应用服务模型。编写出来的基础架构代码，不仅包含了所有对应用配置描述性的语义，而且还是能够被执行的代码，在IaC代码执行之后，你就得到了所期望的虚拟机、应用配置和应用服务。 可测试性：这是一个经常忽略的能力，而在了解之后，你会发现IaC也是编程语言，就是对基础架构进行高级的编程，而且IaC代码本身和它的运行结果都是可以测试的。在执行前对其语义语法测试，在运行以后对其运行结果测试。Chef在这方面表现的尤为突出。  配置管理 我可能是最早的一批进行ITIL配置管理实践，CMDB建设的这批人；我以前和甲方客户有着大量的关于配置管理和CMDB的对话，所经历过的项目也非常煎熬。而在DevOps场景下，感觉以前的经历也是很有意思的，只是我现在说到的CI，在没有特指的情况下，是持续集成的概念，还不是配置项了。
 Process for establishing and maintaining consistency of a product’s performance, functional and physical attributes with its requirements, design and operational information throughout its life。</description>
    </item>
    
    <item>
      <title>BMC Atrium CMDB CI数据迁移</title>
      <link>https://martinliu.cn/2011/01/12/bmc-atrium-cmdb-ci/</link>
      <pubDate>Wed, 12 Jan 2011 05:08:23 +0000</pubDate>
      
      <guid>https://martinliu.cn/2011/01/12/bmc-atrium-cmdb-ci/</guid>
      <description>在不同的CMDB服务器之间做数据迁移之前一定要注意两点：1）保持两边的CDM相同；2）先导入CI数据在导入CI相关的关系数据。另外就是每个类导入完毕之后要做数据完整性和正确性的抽检。以下使用的工具是cmdbdriver，该命令初始化和一般性的参数介绍请参考相关文档。
CI数据导出示例
Command: xexpdt XEXPORT DATA Export instance data from all classes? (F): Classes to export data from: Class and its subclasses, From namespace (1,2) (1): Namespace (): BMC.CORE Class name (): BMC_ComputerSystem Dataset ID (): BMC.ASSET Filename for exported data: C:\DEMO\cs-ci Exporting Class BMC_ComputerSystem i=0: namespaceName = BMC.CORE, className = BMC_ComputerSystemExported without errorsExporting Class BMC_MainframeExporti ng Class BMC_PrinterExporting Class BMC_StorageSubsystem CMDBExportData results ReturnCode: OK Status List : 0 items</description>
    </item>
    
    <item>
      <title>规划CMDB数据填充-001</title>
      <link>https://martinliu.cn/2010/06/04/plan-cmdb-population-001/</link>
      <pubDate>Fri, 04 Jun 2010 06:13:20 +0000</pubDate>
      
      <guid>https://martinliu.cn/2010/06/04/plan-cmdb-population-001/</guid>
      <description>&lt;p&gt;From 《Step by step to build a CMDB》步骤17-规划CMDB数据填充&lt;/p&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;p&gt;在这一CMDB关键的步骤中，会为CMDB的初始化CI数据填充，做精细的计划。需要考虑到所有CI数据，把不同CI类型对应到不同的数据集中，安排正确的顺序将这些数据集CMDB。其中定义对应的规则来调和重复数据是很重要的，不仅在CMDB初始化数据填充阶段重要，在以后的日常维护过程中也是非常重要的。做出了本阶段的详细规划后，这样在第18步即“选择自动化CMDB填充工具”时，就能考虑需要什么样的配置发现和自动化工具了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://pursuitmag.com/wp-content/uploads/2010/01/private-investigator-database.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际上，把数据填充到CMDB中是非常基础的工作，必须事前做好充分的数据范围和类型的分析。对于一个典型的CMDB数据填过程来说，将需要做如下工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立里项目程碑和高阶项目计划，以及配套的支撑数据库和操作流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安排项目启动会议，单周或者双周的项目进度沟通会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;识别子项目（每个数据集分为一个子项目），建立每个子项目的目标和需求清单。识别和制定项目工作活动内容，确定项目的工作流程，并且按照项目计划排程所有活动。包括：
&amp;mdash;并行开展项目（用户界面定制，DSL数据填充）；
&amp;mdash;串行开展项目（发现工具，数据调和，等等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为每个子项目分配项目负责人，让他们来负责汇报项目的进展、问题升级和下一步的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为所有项目参与人员建立一个开放的沟通平台，包括所有内部、外部人员（邮件组方式，数据库、通报）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为可能出现的紧急事件预留至少10%的时间和预算的缓冲。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
